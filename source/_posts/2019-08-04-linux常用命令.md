---

title: linux常用命令
tags:
  - linux
  - 命令
  - awk
  - 更新ing
categories:
  - linux
date: 2019-08-04 19:21:32
---
<Excerpt in index | 首页摘要> 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）

<!-- more -->
<The rest of contents | 余下全文>



### uniq

uniq命令用于报告或忽略文件中的重复行，**查重复行的时候，只会检查相邻的行**，因此一般与[sort](http://man.linuxde.net/sort)命令结合使用，让重复的排在一起。比如下面：`aa` 统计结果是出现了 2 次，后面又有出现 1 次的 `aa`

```
# 文本
aa
aa
c
aa

# uniq 后
uniq -c 
2 aa
1 c
1 aa
```

常用参数：

```
-c或——count：			在每列旁边显示该行重复出现的次数；
-u或——unique：		仅显示出一次的行列；
-d或--repeated：		仅输出重复出现的行列，且重复的只输出一行；
-D, --all-repeated   仅输出重复的行，有几行输出几行  
-i, --ignore-case    不区分大小写  
-w<字符位置>或--check-chars=<字符位置>   指定要比较的前 n 个字符，忽略后面的内容
-f<栏位>或--skip-fields=<栏位>         忽略前n列（空格分割），-f 1 忽略第一列
-s<字符位置>或--skip-chars=<字符位置>   忽略前n个字符 -s 4 忽略前 4 个字符
-z 忽略换行(不知道有什么用)
```
提供的测试文件
```
this is a test  
this is a test  
this is a test  
i am tank  
i love tank  
i love tank  
this is a test  
whom have a try  
WhoM have a try 
WhoM have a try1
you  have a try  
i want to abroad  
those are good men  
we are good men  
```

参考：http://blog.51yip.com/shell/1022.html

### sort

|      |                         |                                                              |
| ---- | ----------------------- | ------------------------------------------------------------ |
| -b   | --ignore-leading-blanks | 排序时忽略起始的空白                                         |
| -c   | --check                 | 不排序，但检查输入数据是不是已排序；未排序的话，报告         |
| -t   | --field-separator=SEP   | 指定分隔符，如果是`\t`，需要这样`sort -t$'\t' file`          |
| -u   | --unique                | 在输出行中去除重复行                                         |
| -n   | --numeric-sort          | 默认是字符串比较，指定-n使用数值比较                         |
| -g   | --general-number-sort   | 按通用数值来排序（跟-n不同，把值当浮点数来排序，支持科学 计数法表示的值） |
| -r   | --reverse               | 默认从小到大，指定后改为从大到小排序                         |
| -f   | --ignore-case           | 默认情况下，会将大写字母排在前面；这个参数会忽略大小写       |
| -o   | --output=file           | 排序结果输出到指定文件，对于**保存到原文件很有用**，不然是可以用重定向的 |
| -m   | --merge                 | 将两个已排序数据文件合并                                     |
| -k   | --key=POS1[,POS2]       | 指定排序的列，排序从POS1位置开始；如果指定了POS2的话， 到POS2位置结 束 |
| -z   | --zero-terminated       | NULL字符作为行尾，而不是用换行符                             |

#### -k

选项的语法格式：

```
FStart.CStart Modifie, FEnd.CEnd Modifier
-------Start---------, -------End--------
 FStart.CStart 选项   ,   FEnd.CEnd 选项
```

这个语法格式可以被其中的逗号`,`分为两大部分，**Start**部分和**End**部分。Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分。

我们重点说说`Start`部分的`FStart`和`C.Start`。`C.Start`也是可以省略的，省略的话就表示从本域的开头部分开始。`FStart.CStart`，其中`FStart`就是表示使用的域，而`CStart`则表示在`FStart`域中**从第几个字符开始算“排序首字符”**。同理，在End部分中，你可以设定`FEnd.CEnd`，如果你省略`.CEnd`，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。

在modifier部分还可以用到哪些选项？	modifier不论写在开始还是结束，都对这个域有效（我观察的）

可以用到b、d、f、i、n 或 r。

-   其中n和r你肯定已经很熟悉了。
-   b表示忽略本域的签到空白符号。
-   d表示对本域按照字典顺序排序（即，只考虑空白和字母）。
-   f表示对本域忽略大小写进行排序。
-   i表示忽略“不可打印字符”，只针对可打印字符进行排序。（有些ASCII就是不可打印字符，比如\a是报警，\b是退格，\n是换行，\r是回车等等）

**如果指定的域都一样，那就会从第一个域、第二个域依次升序比较**

**跨域的设定是个假象**，FStart 与FEnd必须相同



#### 多列排序

sort按照某列排序，一样的话再按某一列排序

```bash
sort  -k2,2 -k5,5 wide_table |grep "DD4486F320A7F0C112E2757C26609769"
```



#### 例子

1.  从公司英文名称的第二个字母开始进行排序：

    ```
      $ sort -t ' ' -k 1.2 facebook.txt
      baidu 100 5000
      sohu 100 4500
      google 110 5000
      guge 50 3000
    ```

     使用了`-k 1.2`，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。

2.  按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序

    ```
    $ sort -n -t ' ' -k 3r -k 2 facebook.txt
    baidu 100 5000
    google 110 5000
    sohu 100 4500
    guge 50 3000
    ```

    在-k 3后面偷偷加上了一个小写字母r。**r和-r选项的作用是一样的，就是表示逆序，不过只对当前域有效**，表示第三个域（员工平均工资）是按照降序排序。此处你还可以加上n，就表示对这个域进行排序时，要按照数值大小进行排序

    ```
    $ sort -t ' ' -k 3nr -k 2n facebook.txt
    baidu 100 5000
    google 110 5000
    sohu 100 4500
    guge 50 3000
    ```

    我们去掉了最前面的-n选项，而是将它加入到了每一个-k选项中了。

3.  只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序

    ```
    $ sort -t ' ' -k 1.2,1.2 -k 3nr facebook.txt
    baidu 100 5000
    google 110 5000
    sohu 100 4500
    guge 50 3000
    ```

    >   我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。

4.  最诡异的排序（跨域是不行的）

    ```
    $ sort -n -k 2.2,3.1 facebook.txt
    guge 50 3000
    baidu 100 5000
    sohu 100 4500
    google 110 5000
    ```

    以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。

    第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。

    又因为sort认为0小于00小于000小于0000….

    因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢？（你可以自己做实验思考一下。）

    答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了。

http://blog.chinaunix.net/uid-10540984-id-313479.html



### grep

#### 常用参数

```bash
grep pattern filename  # 默认支持正则
grep -e pattern1 -e pattern2 filename
```

默认情况下，grep命令用基本的Unix风格正则表达式来匹配模式。Unix风格正则表达式采用特殊字符来定义怎样查找匹配的模式。

需要注意的是：限定连续字符范围 的`{}`符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 ` \{` 与`\}` 来让它失去特殊意义才行。

```bash
grep --color=auto " 在输出行中着重标记出匹配到的模式

-a  # 将 binary 文件以 text 文件的方式搜寻数据
-e  # 如果要指定多个匹配模式，可用-e参数来指定每个模式,grep -e t -e f file 输出了含有字符t或字符f的所有行。
-o 	# 只输出匹配到的文本，如果在同一行中，会分开显示
-v  # 打印出不匹配match_pattern的所有行
-c	# 统计匹配行的数量，并不是匹配的次数。匹配次数需要与-o配合，请看后面的例子
-n  # 打印出匹配字符串所在行的行号,以及该行的内容，如果涉及多个文件，该选项也会随输出结果打印出文件名
-i # 忽略模式中的大小写
-l # 多文件处理时，可以列出匹配模式所在的文件
-L # 与-l相反，它会返回一个不匹配的文件列表
-q # 静默模式（主要用于脚本中，，在命令行中没什么用），只判断是否匹配成功,不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。0表示匹配成功，非0表示匹配失败。

# 显示前后几行
-A # after，显示匹配到的行以及之后的 n 行
-B # before，显示匹配到的行以及之前的 n 行
-C # Center，显示匹配到的行以及前后的 n 
# 如果匹配到多行，为了区分匹配到的字符串，用"--"进行区分，比如：
echo -e "a\nb\nc\na\nb\nc" | grep a -A 1
# a		匹配到第1次
# b
# --
# a		匹配到第2次
# c
```

统计匹配项的数量

```
echo -e "1 2 3 4\nhello\n5 6" | egrep -o "[0-9]" | wc -l
```

#### 扩展用法

egrep命令是grep的一个衍生，支持POSIX扩展正则表达式。POSIX扩展正则表达式含有更 多的可以用来指定匹配模式的字符，增加了额外的正则表达式元字符集。

```bash
grep -E "[a-z]+" filename
#或
egrep "[a-z]+" filename
```

#### 不使用正则表达式

```
grep -F 'str'
fgrep 'str' 
```

`fgrep` 查询速度比`grep`命令快，但是不够灵活：它**只能找固定的文本，而不是正则表达式。**

如果你想在一个文件或者输出中找到包含星号字符的行

```bash
fgrep  '*' /etc/profile
#或
grep -F '*' /etc/profile
```

fgrep则是另外一个版本，支持将匹配模式 指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后 在fgrep命令中用其在一个大型文件中搜索字符串了。

#### 检索文件内容

递归搜索目录中的文件内容（不是文件名）`-R`

```bash
grep "test_function()" ./ -R -n 
# ./miscutils/test.c:16:test_function(); 找到在test.c的第16行
```

等价于`find . -type f | xargs grep "test_function()"`



命令会打印出匹配任意一种模式的行，每个匹配对应一行输出。例如：

```bash
echo this is a line of text | grep -o -e "this" -e "line" this
```

可以将多个模式定义在文件中。选项-f可以读取文件并使用其中的模式（一个模式一行，记得最后留一行空白行，不然最后一种模式匹配不到，很诡异）

```bash
cat pat_file
# ^h.*
# co+l
# 
echo hello \n this is cool | grep -f pat_file 
# hello 
# this is cool
```



####  指定或者排除文件

使用--include选项在目录中递归搜索所有的 .c和 .cpp文件：

```bash
grep "main()" . -r --include *.{c,cpp}
```

>   注意，`some{string1,string2,string3}` 会被扩展成 `somestring1 somestring2 somestring3 `。

 相反的就是`--exclude `

`--exclude-dir`可以排除目录：

```bash
grep main . -r -exclude-dir CVS
```

`--exclude-from FILE`从文件中读取排除文件列表



#### 0值字节后缀的 xargs

xargs命令可以为其他命令提供命令行参数列表。

当文件名作为命令行参数时，建议用0值字节作为文件名终结符，而非空格。因为一些文件名中会包含空格字符，一旦它被误解为终结符， 那么单个文件名就会被视为两个（例如，New file.txt被解析成New和file.txt两个文件名）。

这个问题可以利用0值字节后缀来避免。

grep和find命令可以生成带有0值字节后缀的输出，然后传递 给 xargs，让它产生文件名列表。为了指明输入中的文件名是以0值字节作为终结，需 要在xargs中使用选项-0。

```bash
# 创建测试文件：
echo "test" > file1  
echo "cool" > file2 
echo "test" > file3

# 找出包含有 test 内容的文件名，并以0值字节作为终结符，然后传递给 xargs，让它生成文件名参数列表，之后传递（不用管道符号）给 rm 命令，删除这些文件
grep "test" file* -lZ | xargs -0 rm

# 选项-l告诉grep只输出有匹配出现的文件名。选项-Z使得grep使用0值字节（\0）作为文 件名的终结符。这两个选项通常都是配合使用的。xargs的-0选项会使用0值字节作为输入的分隔符
```

#### 比较两个文件相同的行与不同的行

```bash
grep -Ff  file1 file2   # 输出公共的行
grep -vFf  file1 file2   # 输出不在 file1 的行
```



### tr

#### 基本用法

tr是translate（转换）的简写，基本功能是将字符从一个字符集合映射到另一个集合中

```
tr set1 set2
```

>   注意： `tr`只能通过`stdin` 接收输入，无法通过命令行参数接收 ，如`tr -s '' file`，只能转为 `stdin` 形式，`tr -s ' '< file.txt`

如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1 相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。

```
echo "HELLO WHO IS THIS" | tr 'A-Z' 'a-z'
```

字符集合（字符组）可以使用“起始字符—终止字符”，如果不是有效的连续字符序列， 那么它就会被视为`起始字符`、`—`、`终止字符`这3个元素的集合。也可以使用像`\t`、`\n` 这种特殊字符或其他ASCII字符。可以按照需要追加字符或**字符类**来构造自己的字符组。

| 字符类 | 说明               |
| ------ | ------------------ |
| alnum  | 字母和数字         |
| alpha  | 字母               |
| cntrl  | 控制（非打印）字符 |
| digit  | 数字               |
| graph  | 图形字符           |
| lower  | 小写字母           |
| print  | 可打印字符         |
| punct  | 标点符号           |
| space  | 空白字符           |
| upper  | 大写字母           |
| xdigit | 十六进制字符       |

字符类的使用方法`tr '[:lower:]' '[:upper:]'`



#### 其他参数

```
tr [options] set1  [set2]
-d     # 删除(delete)set1 中的字符
-c     # tr会将不在set1中的字符转换成set2中的字符,set2只能是一个字符
-d -c  # 只保留set1的字符，不需要set2
-s     # 删除重复字符，只留下一个
```



#### 例子

tr命令可以用来加密。ROT13是一个著名的加密算法。在ROT13算法中，字符会被移动13 个位置，因此文本加密和解密都使用同一个函数：

```bash
echo "tr came, tr saw, tr conquered." | tr 'a-zA-Z' 'n-za-mN-ZA-M'
```

将制表符转换成单个空格：

```bash
tr '\t' ' ' < file.txt
```

 删除字符

```
echo "Hello 123 world 456" | tr -d '0-9' 
# Hello world
```

只保留set1 的字符

```
echo hello 1 char 2 next 4 | tr -d -c '0-9 \n'
# 124
```

压缩空格

```
echo "GNU  is   not     UNIX.     Recursive       GNU is not UNIX. Recursive right ?" | tr -s ' '
```



### cut

cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、 CSV文件或是由空格分隔的文件。

>   如果空格的长度不一致，需要使结合`tr`命令，进行字符串转换



每列被称为一个**字段**，默认分隔符是制表符`\t`

```
-d"\t"    # 指定分割符为"\t"，默认就是制表符，因此可以不写
-f2,3     # 显示2,3列的内容,f2可以不用空格分开
-f2-4     # 显示第2到4列(field)的内容，2-5 的用法看后面表格说明
-c2-5     # 显示第2到5个字符(character)，注意不能与-d 组合
-b2-5     # 显示第2到5个字节(byte)，注意不能与-d 组合
--complement # 与-f 组合使用，显示f没有指定的列，就是取反
--output-delimiter    指定输出时的列分隔符
```

```bash
cut range_fields.txt -c1-3,6-9 --output-delimiter "," 
# abc,fghi 
# abc,fghi 
# abc,fghi 
# abc,fghi
```



| 选取方式 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| N-       | 从第N个字节、字符或字段开始到行尾                            |
| N-M      | 从第N个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段 |
| -M       | 从第1个字节、字符或字段开始到第M个（包括第M个在内）字节、字符或字段 |

```bash
cut -c -2 range_fields.txt    # 打印前2个字符
cut -c2-5 range_fields.txt    # 打印第2个到第5个字符
```



### sed

sed是stream editor（流编辑器）的缩写。它最常见的用法是进行文本替换。**默认不修改原文件，只显示修改后的结果。**

```
sed [-hnV][-e<script>][-f<script文件>][文本文件]

-e 'script1;script2'
-f script_file # 从文本中读取大量指令，一行一个，以换行结束
-i # 保存到原文件
-n或--quiet或--silent # 仅显示script处理后的结果。
```



要是我们想就地（in place）修改文件内容，可以使用选项`-i`保存到原文件中。值得**推荐的做法**是

-   先使用不带`-i`选项的`sed`命令，以确保正则表达式没有问题，如果结果符合要求，再加入-i选项将更改写入文件。

-   也可以使用`sed -i.bak 's/abc/def/' file`，这时的sed不仅替换文件内容，还会创建一个名为`file.bak`的文件，其中包含着原始文件内容的副本。

##### 替换`s`

```
s/old/new/          # 替换每行第1个匹配到的字符串
s/old/new/2         # 替换每行第2个匹配到的字符串
s/old/new/g         # 替换全部
s/old/new/2g        # 只替换第2次及之后匹配到的字符串
```

```bash
echo thisthisthisthis | sed 's/this/THIS/2g' 
# thisTHISTHISTHIS 
```

###### 替换标记

```
s/pattern/replacement/flags
```

有4种可用的替换标记： 

-   数字，表明新文本只替换每行第几处模式匹配的地方； 
-   g，表明新文本将会替换所有匹配的文本； 
-   p，表明原先行的内容要打印出来；
-    w file，将匹配到的行替换的结果写到指定的file中。



p替换标记会打印与替换命令中指定的模式匹配的行替换后的结果。这通常会和sed的-n选项一起使用。-n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是 只输出被替换命令修改过的行。

```bash
$ cat data5.txt 
This is a test line.
This is a different line.

$ $ sed -n 's/test/trial/p' data5.txt 
This is a trial line.
```

w替换标记会产生与 p 模式同样的输出，不过会将输出保存到指定文件中。



###### 分隔符

`sed`命令会将`s`之后的字符视为命令分隔符。这允许我们更改默认的分隔符`/`：

```
sed 's:text:replace:g' 
sed 's|text|replace|g'
```

如果作为分隔符的字符出现在模式中，必须使用`\`对其进行转义

###### 指定行

方式1（数字）：

在`s`前添加行编辑即可

```bash
sed '2s/dog/cat/' data1.txt   # 只修改地址指定的第2行的文本
sed '2,3s/dog/cat/' data1.txt # 只修改地址指定的第2，3行的文本
sed '2,$s/dog/cat/' data1.txt # 修改从某行开始的所有行
```



方式2（正则）：

```bash
sed '/pattern/s/bash/csh/' /etc/passwd  # 使用 pattern 正则表达式过滤
```





**已匹配字符串标记（&）**

在sed中，我们可以用&指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹 配的内容：

```
echo this is an example | sed 's/\w+/[&]/g'
# [this] [is] [an] [example]
```

**子串匹配标记（\num）**

 匹配正则中的子表达式，第1 个是`\1`，第 2 个是`\2`，以此类推

```
echo this is digit 7 in a number | sed 's/digit \([0-9]\)/\1/' 
# this is 7 in a number
```

**多表达式**

```bash
sed 'expression; expression'
sed 'expression' | sed 'expression'
sed -e 'expression' -e 'expression'
sed -e 'expression; expression'
sed -e '
> s/brown/green/
> s/fox/elephant/
> s/dog/cat/' data1.txt
```

例子

```
echo abc | sed 's/a/A/;s/c/C/'
echo abc | sed 's/a/A/' | sed 's/c/C/'
echo abc | sed -e 's/a/A/' -e 's/c/C/'
echo abc | sed -e 's/a/A/; s/c/C/'
# AbC
```

**单引号与双引号的区别**

sed表达式**通常用单引号来引用**。如果想在sed表达式中使用变量，双引号就能派上用场了。

```
text=hello 
echo hello world | sed "s/$text/HELLO/" 
# HELLO world
```

##### 多命令

如果需要在匹配到的行上执行多条命令，可以用`{}`将多条命令组合在一起，同时指定过滤的行号，或者匹配模式。

多条命令之间用`;`分割，或者分成多行书写。

```bash
# 一行内多个命令
sed -n '/root/{s/bash/blueshell/;p;q}' /etc/passwd 

# 分成多行执行多个命令
sed '3,${
> s/brown/green/
> s/lazy/active/
> }' data1.txt
```



##### 插入`a`与`i`

```bash
sed '[address]command\
new line'
```

插入（insert）命令（i）会在指定行前插入文本，（插入的文本要带有换行，否则就直接插入在指定行的头部）

附加（append）命令（a）会在指定行后添加文本，（如果文本没换行，会与下一行在同一行）

可以指定一个行地址，匹配一个数字行号或文本模式

>   这两条命令的费解之处在于它们的格式。它们不能在一行内使用。你必须先输入`i`或者`a`，然后使用`\`进行换行，接着输入要插入或者附加的内容。

```bash
# 脚本中的写法
$ echo "Test Line 2" | sed '1i\   # 在第一行前插入
Test Line 1\     # 换行，否则两行文本会在一同一行
' 
Test Line 1 
Test Line 2

$ echo "Test Line 2" | sed '/Line/a\   # 在包含Line的一行添加
Test Line 1\
' 

Test Line 2 
Test Line 1
```



###### 插入多行

插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后 一行。

```bash
sed '1i\
> This is one line of new text.\
> This is another line of new text.' data6.txt 

This is one line of new text.
This is another line of new text.
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
$
```



##### 删除行 `d`

删除命令`d`名副其实，它会删除匹配指定寻址模式的所有行。

支持指定行`sed '2,3d' data6.txt`

通过特定行区间指定：`sed '2,3d' data6.txt`

模式匹配特性也适用于删除命令`sed '/number 1/d' data6.txt`

也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。

-   sed编辑器会删除两个指定行之间 的所有行（包括指定的行）。**如果没有找到停止模式，所以就将数据流中的剩余行全部删除了。**
-   你指定的第1个模式 会“打开”行删除功能，第2个模式会“关闭”行删除功能。之后**再遇到第1个模式会再打开删除功能**。

```bash
$ cat data7.txt 
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
This is line number 1 again.   # 再次触发删除功能
This is text you want to keep. 
This is the last line in the file. 

$ sed '/1/,/3/d' data7.txt 
This is line number 4.

$
```



##### 字符转换`y`

转换（transform）命令（y）是唯一可以处理单个字符的sed编辑器命令。

```
[address]y/inchars/outchars/
```

```bash
sed 'y/123/789/' data8.txt 
This is line number 7.
This is line number 8.
This is line number 9.
This is line number 4.
This is line number 7 again.
This is yet another line.
This is the last line in the file. 
$
```



转换命令会对inchars和outchars值进行一对一的映射。

如果inchars和outchars的长度不同，则sed编辑器会产生一 条错误消息。

转换命令是一个全局命令，你无法限定只转换在特定地方出现的字符。





#####  打印命令

1.  p命令用来打印文本行； 
2.  等号（=）命令用来打印行号； 
3.   l（小写的L）命令用来列出行。

###### p 命令

```bash
echo "this is a test" | sed 'p'
this is a test
this is a test
```

它所做的就是打印已有的数据文本

最常见的用法是与`-n`配合打印包含匹配文本模式的行。用-n选项，你可以禁止输出其他行，只打印包含匹配文本模式的行。

```
$ cat data6.txt 
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.

$ $ sed -n '/number 3/p' data6.txt 
This is line number 3.
```



修改前后对比

```bash
$ sed -n '/3/{
> p
> s/line/test/p
> }' data6.txt 
This is line number 3. 
This is test number 3. $
```



###### `=`等号

等号命令会打印行在**数据流中的当前行号**。

```
sed '=' data1.txt 
1 
The quick brown fox jumps over the lazy dog.
2 
The quick brown fox jumps over the lazy dog.
```



```bash
$ sed -n '/number 4/{
> =
> p
> }' data6.txt 4 
This is line number 4. 
$
```



###### 显示特殊字符`l`

命令（`l`）可以打印数据流中的文本和不可打印的ASCII字符。任何不可打印 字符要么在其八进制值前加一个反斜线，要么使用标准C风格的命名法（用于常见的不可打印字符），比如\t，来代表制表符。



制表符的位置使用\t来显示。行尾的美元符表示换行符。

```bash
$ cat data10.txt 
This line contains an escape	character.

$ $ sed -n 'l' data10.txt 
This line contains an escape\tcharacter. \a$ 
```



##### 保存命令`w`

w命令用来向文件写入行。该命令的格式如下：

```
[address]w filename
```

`filename`可以使用相对路径或绝对路径，但不管是哪种，运行sed编辑器的用户都必须有文 件的写权限。

地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式。

```bash
$ cat data11.txt 
Blum, R Browncoat 
McGuiness, A Alliance
Bresnahan, C Browncoat 
Harken, C Alliance 
$ 
$ sed -n '/Browncoat/w Browncoats.txt' data11.txt 
$ 
$ cat Browncoats.txt 
Blum, R Browncoat 
Bresnahan, C Browncoat
```



##### 读取命令

读取（read）命令（r）允许你将另一个文件中的数据插入到数据流中。

```
[address]r filename
```

地址区间**只能指定单独一个行号或文本模式地址**。sed编辑器会将文件中的**所有文本行**插入到指定地址后。

```bash
$ cat data12.txt 
This is an added line.
This is the second added line. 
$ 
$ sed '3r data12.txt' data6.txt 
This is line number 1.
This is line number 2.
This is line number 3.
This is an added line.
This is the second added line. 
This is line number 4.
$
$ sed '/number 2/r data12.txt' data6.txt 
This is line number 1.
This is line number 2.
This is an added line.
This is the second added line.
This is line number 3.
This is line number 4.
$
```



另一个很酷的用法是和删除命令配合使用：利用另一个文件中的数据来替换文件中的占位文本。

```bash
$ cat notice.std 
Would the following people:
LIST 
please report to the ship's captain. 
$
$ sed '/LIST/{
> r data11.txt
> d
> }' notice.std 
Would the following people:
Blum, R Browncoat 
McGuiness, A Alliance 
Bresnahan, C Browncoat 
Harken, C Alliance 
please report to the ship's captain. $

现在占位文本已经被替换成了数据文件中的名单。
```



### 压缩命令

压缩命令 linux 命令行与 shell 脚本编程大全 4.33 



### 其他

EOF（End-of-File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。



参考：https://awk.readthedocs.io/en/latest/chapter-one.html

