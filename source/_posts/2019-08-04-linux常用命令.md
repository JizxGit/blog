---
title: linux常用命令
tags:
  - linux
  - 命令
  - awk
  - 更新ing
categories:
  - linux
date: 2019-08-04 19:21:32
---
<Excerpt in index | 首页摘要> 

处理数据常用的命令，包括 sort、awk、cut 等常用命令（持续 ing）

<!-- more -->
<The rest of contents | 余下全文>

#### sort

|      |                                                              |
| ---- | ------------------------------------------------------------ |
| -t   | 指定分隔符                                                   |
| -u   | 在输出行中去除重复行                                         |
| -n   | 默认是字符串比较，指定-n使用数值比较                         |
| -r   | 默认从小到大，指定后改为从大到小排序                         |
| -o   | 排序结果输出到指定文件，对于**保存到原文件很有用**，不然是可以用重定向的 |
| -k   | 指定排序的列，具体用法非常多，参考下面的讲解                 |

##### -k

选项的语法格式：

```
FStart.CStart Modifie, FEnd.CEnd Modifier
-------Start---------, -------End--------
 FStart.CStart 选项   ,   FEnd.CEnd 选项
```

这个语法格式可以被其中的逗号`,`分为两大部分，**Start**部分和**End**部分。Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分。

我们重点说说`Start`部分的`FStart`和`C.Start`。`C.Start`也是可以省略的，省略的话就表示从本域的开头部分开始。`FStart.CStart`，其中`FStart`就是表示使用的域，而`CStart`则表示在`FStart`域中**从第几个字符开始算“排序首字符”**。同理，在End部分中，你可以设定`FEnd.CEnd`，如果你省略`.CEnd`，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。

在modifier部分还可以用到哪些选项？	modifier不论写在开始还是结束，都对这个域有效（我观察的）

可以用到b、d、f、i、n 或 r。

- 其中n和r你肯定已经很熟悉了。
- b表示忽略本域的签到空白符号。
- d表示对本域按照字典顺序排序（即，只考虑空白和字母）。
- f表示对本域忽略大小写进行排序。
- i表示忽略“不可打印字符”，只针对可打印字符进行排序。（有些ASCII就是不可打印字符，比如\a是报警，\b是退格，\n是换行，\r是回车等等）

**如果指定的域都一样，那就会从第一个域、第二个域依次升序比较**

**跨域的设定是个假象**，FStart 与FEnd必须相同





##### 例子

1. 从公司英文名称的第二个字母开始进行排序：

   ```
     $ sort -t ' ' -k 1.2 facebook.txt
     baidu 100 5000
     sohu 100 4500
     google 110 5000
     guge 50 3000
   ```

    使用了`-k 1.2`，表示对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序。

2. 按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序

   ```
   $ sort -n -t ' ' -k 3r -k 2 facebook.txt
   baidu 100 5000
   google 110 5000
   sohu 100 4500
   guge 50 3000
   ```

   在-k 3后面偷偷加上了一个小写字母r。**r和-r选项的作用是一样的，就是表示逆序，不过只对当前域有效**，表示第三个域（员工平均工资）是按照降序排序。此处你还可以加上n，就表示对这个域进行排序时，要按照数值大小进行排序

   ```
   $ sort -t ' ' -k 3nr -k 2n facebook.txt
   baidu 100 5000
   google 110 5000
   sohu 100 4500
   guge 50 3000
   ```

   我们去掉了最前面的-n选项，而是将它加入到了每一个-k选项中了。

3. 只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序

   ```
   $ sort -t ' ' -k 1.2,1.2 -k 3nr facebook.txt
   baidu 100 5000
   google 110 5000
   sohu 100 4500
   guge 50 3000
   ```

   > 我们使用了-k 1.2,1.2的表示方式，表示我们“只”对第二个字母进行排序。（如果你问“我使用-k 1.2怎么不行？”，当然不行，因为你省略了End部分，这就意味着你将对从第二个字母起到本域最后一个字符为止的字符串进行排序）。

4. 最诡异的排序（跨域是不行的）

   ```
   $ sort -n -k 2.2,3.1 facebook.txt
   guge 50 3000
   baidu 100 5000
   sohu 100 4500
   google 110 5000
   ```

   以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。

   第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。

   又因为sort认为0小于00小于000小于0000….

   因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢？（你可以自己做实验思考一下。）

   答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了。

http://blog.chinaunix.net/uid-10540984-id-313479.html





#### awk



##### 基本组成

```
awk [option] 'pattern { action }' file
```

引号之间的部分是awk编程语言写就的程序

每个模式依次测试每个输入行。对于匹配到行的模式，其对应的动作（也许包含多步）得到执行，然后读取下一行并继续匹配，直到所有的输入读取完毕。

由于模式和动作两者任一都是可选的，所以需要使用大括号包围动作以区分于其他模式。



option

```
-F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:
-v var=value   赋值一个用户定义变量，将外部变量传递给awk
-f scripfile  从脚本文件中读取awk命令
```



##### 模式种类

1. BEGIN { 语句 }

在读取任何输入前执行一次 语句

2. END { 语句 }

读取所有输入之后执行一次 语句

3. 表达式 { 语句 }

对于 表达式 为真（即，非零或非空）的行，执行 语句

4. /正则表达式/ { 语句 }

如果输入行包含字符串与 正则表达式 相匹配，则执行 语句

5. 组合模式 { 语句 }

一个 组合模式 通过与（&&），或（||），非（|），以及括弧来组合多个表达式；对于组合模式为真的每个输入行，执行 语句

6. 模式1，模式2 { 语句 }

范围模式(range pattern)匹配从与 模式1 相匹配的行到与 模式2 相匹配的行（包含该行）之间的所有行，对于这些输入行，执行语句 。

> BEGIN和END不与其他模式组合。范围模式不可以是任何其他模式的一部分。BEGIN和END是仅有的必须搭配动作的模式。

##### 输入方式

```
awk 'pattern { action }' files
awk 'pattern { action }' file1 file2
awk 'pattern { action }'  # 进入交互模式，直到ctrl+d结束输入
```

##### 将指令保存在文件中

当 引号内的 程序过长时，可以单独保存在文件中，假设存在文件 progfile ，输入命令行：:

```
awk -f progfile	file
```



##### 功能

###### 打印输出

**打印一行**

```
{ print }
# 或者，由于 $0 表示整行,
{ print $0 }
```

**打印特定列**

使用一个 print 语句可以在同一行中输出不止一个字段. 下面的程序输出了每 行输入中的第一和第三个字段

```
{ print $1, $3 }
```

**NF** 列总数

该变量表示一共有多少列

```
{ print NF, $1, $NF } # 打印第一列 和最后一列
```

**计算和打印**

你也可以对字段的值进行计算后再打印出来. 下面的程序

```
{ print $1, $2 * $3 }
```

**NR 打印行号**

存储当前已经读取了多少行的计数。给每一行加上行号:

```
{ print NR, $0 }
```

**在输出中添加内容**

双引号内的文字将会在字段和计算的值中插入输出.

```
{ print "total pay for", $1, "is", $2 * $3 }
```

**排序输出**

最简单的方式是使用awk将每位员工的总薪酬置于其记录之前，然后利用**sort**命令来处理awk的输出。Unix上，命令行如下:

```
awk '{ printf("%6.2f    %s\n", $2 * $3, $0) }' emp.data | sort

```

**打印表头，表尾**

 BEGIN 用于匹配第一个输入文件的第一行之前的位置， END 则用于匹配处理过的最后一个文件的最后一行之后的位置

```
awk 'BEGIN {print "Name Rate Hour";print "========="} {print $0}' file

```

**字符串拼接**

print语句块中双引号是被当作拼接符使用

```
# 将names变量与当前行的的$1以及空格进行拼接，赋值给names
 { names = names $1 " "}
END { print names }

```

**只打印最后一行**

**打印最后一个输入行**

虽然在 END 动作中 NR 还保留着它的值，但 $0 没有。程序是打印最后一个输入行的一种方式

```
    { last = $0 }
END { print last }

```



###### 高级输出

printf 语句的形式如下：:

```
printf(format, value1, value2, ..., valuen)

```

其中 format 是字符串，包含要逐字打印的文本，穿插着 format 之后的每个值该如何打印的规格(specification)。一个规格是一个 % 符，后面跟着一些字符，用来控制一个 value 的格式。第一个规格说明如何打印 value1 ，第二个说明如何打印 value2 ，... 。因此，有多少 value 要打印，在 format 中就要有多少个 % 规格。（与C语言很像）

这里有个程序使用 printf 打印每位员工的总薪酬：:

```
{ printf("total pay for %s is $%.2f\n", $1, $2 * $3) }

```

###### 选择、过滤

**数值判断**

```
$2 * $3 > 50 { printf("$%.2f for %s\n", $2 * $3, $1) }

```

**文本内容选择，支持正则**

```
$1 == "Susie" { print }
$1~/正则内容/ { print $1} #对某一列进行正则
/正则内容/ { print $1}	# 对整行进行匹配

```

**多条件组合**

逻辑操作符与 && ， 或 || ， 以及非 ! 对模式进行组合

```
$2 >= 4 || $3 >= 20 {print}

```



###### 计算，定义变量

一个动作就是一个以新行或者分号分隔的语句序列。

**定义变量**

这个程序使用一个变量 emp 来统计工作超过15个小时的员工的数目：

```
$3 > 15 { emp = emp + 1 }
END     { print emp, "employees worked more than 15 hours" }

```

对于第三个字段超过15的每行， emp 的前一个值加1。以 emp.data 为输入，该程序产生：:

```
3 employees worked more than 15 hours

```

用作数字的awk**变量的默认初始值为0**，所以我们不需要初始化 emp 。



awk变量可以保存数字也**可以保存字符串**。这个程序会找出时薪最高的员工：

```
# 如果$2大于最大值，则更新为当前行的信息
$2 > maxrate { maxrate = $2; maxemp = $1 }
END { print "highest hourly rate:", maxrate, "for", maxemp }

```





###### 内置函数

length：字符长度

请参考该网址，可以看到更多的函数说明：https://man.linuxde.net/awk



###### 控制语句（用到再看）

仅可以在动作中使用

**if else if  else语句**

如下程序将计算时薪超过6美元的员工的总薪酬与平均薪酬。它使用一个 if 来防范计算平均薪酬时的零除问题。

```
$2 > 6 { n = n + 1; pay = pay + $2 * $3 }
END    { if (n > 0)
            print n, "employees, total pay is", pay,
                     "average pay is", pay/n
         else
             print "no employees are paid more than $6/hour"
        }

```

emp.data 的输出是：:

```
no employees are paid more than $6/hour

```

if-else 语句中，if 后的条件会被计算。如果为真，执行第一个 print 语句。否则，执行第二个 print 语句。注意我们可以使用一个逗号将一个长语句截断为多行来书写。

**while语句**

一个 while 语句有一个条件和一个执行体。条件为真时执行体中的语句会被重复执行。这个程序使用公式 value=amount(1+rate)yearsvalue=amount(1+rate)years

来演示以特定的利率投资一定量的钱，其数值是如何随着年数增长的。

```
# interest1 - 计算复利
#   输入: 钱数    利率    年数
#   输出: 复利值

{   i = 1
    while (i <= $3) {
        printf("\t%.2f\n", $1 * (1 + $2) ^ i)
        i = i + 1
    }
}

```

条件是 while 后括弧包围的表达式；循环体是条件后大括号包围的两个表达式。 printf 规格字符串中的 \t 代表制表符； ^ 是指数操作符。从 # 开始到行尾的文本是注释，会被awk忽略，但能帮助程序的读者理解程序做的事情。

你可以为这程序输入三个一组的数字，看看不一样的钱数、利率、以及年数会产生什么。例如，如下事务演示了1000美元，利率为6%与12%，5年的复利分别是如何增长的：:

```
$ awk -f interest1
1000 .06 5
        1060.00
        1123.60
        1191.02
        1262.48
        1338.23
1000 .12 5
        1120.00
        1254.40
        1404.93
        1573.52
        1762.34

```

**for语句**

另一个语句， for ，将大多数循环都包含的初始化、测试、以及自增压缩成一行。如下是之前利息计算的 for 版本：:

```
# interest1 - 计算复利
#   输入: 钱数    利率    年数
#   输出: 每年末的复利

{ for (i = 1; i <= $3; i = i + 1)
    printf("\t%.2f\n", $1 * (1 + $2) ^ i)
}

```

初始化 i = 1 只执行一次。接下来，测试条件 i <= $3 ；如果为真，则执行循环体的 printf 语句。循环体执行结束后执行自增 i = i + 1 ，接着由另一次条件测试开始下一个循环迭代。代码更加紧凑，并且由于循环体仅是一条语句，所以不需要大括号来包围它。

###### 数组变量（用到再看）

将按行逆序打印输入。第一个动作将输入行存为数组 line 的连续元素；即第一行放在 line[1] ，第二行放在 line[2] , 依次继续。 END 动作使用一个 while 语句从后往前打印数组中的输入行：

```
# 反转 - 按行逆序打印输入

    { line[NR] = $0 }  # 记下每个输入行
END { i = NR           # 逆序打印
      while (i > 0) {
        print line[i]
        i = i - 1
      }
    }

```

以 emp.data 为输入，输出为

```
Susie    4.25   18
Mary     5.50   22
Mark     5.00   20
Kathy    4.00   10
Dan      3.75   0
Beth     4.00   0

```





参考：https://awk.readthedocs.io/en/latest/chapter-one.html

