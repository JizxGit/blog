---
title: linux知识点
tags:
  - linux
categories:
  - linux
date: 2019-10-11 20:17:35
---
<Excerpt in index | 首页摘要> 

<!-- more -->
<The rest of contents | 余下全文>



内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交换空间（swap space）。



### 系统的运行级别

运行级为1时，只启动基本的系统进程以及一个控制台终端进程。我们称之为单用户模式。

标准的启动运行级是3。在这个运行级上，大多数应用软件，比如网络支持程序，都会启动。 

另一个Linux中常见的运行级是5。在这个运行级上系统会启动图形化的X Window系统，允许用 户通过图形化桌面窗口登录系统。



### man

每个内容区域都分配了一个数字， 从1开始，一直到9，如表所示。

| 区号 | 所涵盖的内容             |
| :--- | :----------------------- |
| 1    | 可执行程序或shell命令    |
| 2    | 系统调用                 |
| 3    | 库调用                   |
| 4    | 特殊文件                 |
| 5    | 文件格式与约定           |
| 6    | 游戏                     |
| 7    | 概览、约定及杂项         |
| 8    | 超级用户和系统管理员命令 |
| 9    | 内核例程                 |

工具通常提供的是命令所对应的**最低编号**的内容。



### 常见Linux目录名称

| 目 录  | 用处                                                         |
| :----- | :----------------------------------------------------------- |
| /      | 虚拟目录的根目录。通常不会在这里存储文件                     |
| /bin   | 二进制目录，存放许多用户级的GNU工具                          |
| /boot  | 启动目录，存放启动文件                                       |
| /dev   | 设备目录， Linux在这里创建设备节点                           |
| /etc   | 系统配置文件目录                                             |
| /home  | 主目录， Linux在这里创建用户目录                             |
| /lib   | 库目录，存放系统和应用程序的库文件                           |
| /media | 媒体目录，可移动媒体设备的常用挂载点                         |
| /mnt   | 挂载目录，另一个可移动媒体设备的常用挂载点                   |
| /opt   | 可选目录，常用于存放第三方软件包和数据文件                   |
| /proc  | 进程目录，存放现有硬件及当前进程的相关信息                   |
| /root  | root用户的主目录                                             |
| /sbin  | 系统二进制目录，存放许多GNU管理员级工具                      |
| /run   | 运行目录，存放系统运作时的运行时数据                         |
| /srv   | 服务目录，存放本地服务的相关文件                             |
| /sys   | 系统目录，存放系统硬件信息的相关文件                         |
| /tmp   | 临时目录，可以在该目录中创建和删除临时工作文件               |
| /usr   | 用户二进制目录，**大量用户级的GNU工具**和数据文件都存储在这里 |
| /var   | 可变目录，用以存放经常变化的文件，比如日志文件               |

常见的目录名均基于文件系统层级标准（filesystem hierarchy standard，FHS）。http://www.pathname.com/fhs。



### 虚拟目录与挂载点

Linux虚拟目录中比较复杂的部分是它如何协调管理各个存储设备。在Linux PC上安装的**第一块硬盘称为根驱动器**。根驱动器包含了虚拟目录的核心，其他目录都是从那里开始构建的。Linux会在根驱动器上创建一些特别的目录，我们称之为**挂载点**（mountpoint）。挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上它们却存储在另外一个驱动器中。

通常系统文件会存储在根驱动器中，而用户文件则存储在另一驱动器中。



### glob 模式匹配

-   问号（?）代表一个字符； 
-   星号（*）代表零个或多个字符。 问号可用于过滤器字符串中替代任意位置的单个字符。
-   使用中括号`[ai]pt`，字母范围`[a – i]`，感叹号`[!a]`将不需要的内容排除在外。



### 符号链接

-   软链接(符号链接)：类似window 的快捷方式，`ln -s`选项来创建符号链接。软链接`sl_data_file`仅仅只是指向`data_file`而已。它们的内容并不相同，是两个完全不同的文件。
-   硬链接：`ln`，硬链接会创建独立的虚拟文件，其中包含了原始文件的信息及位置。但是它们**从根本上而言是同一个文件**（带有硬链接的文件**共享inode编号**）。引用硬链接文件等同于引用了源文件。

>   只能对处于同一存储媒体的文件创建**硬链接**。要想在不同存储媒体的文件之间创建链接， 只能使用**符号链接**。
>
>   用不着复制链接文件，可以创建原始文件的另一个链接。
>
>   千万别创建软链接文件的软链接。



### shell配置文件加载顺序 

http://ddrv.cn/a/173848/



### 通配符（Wildcard）

在 Shell 中命令中，通常会使用通配符表达式来匹配一些文件，如以下命令可以查找当前目录下所有后缀为 .xml 的文件

```
find . -name "*.xml" 
```

Shell 中可以使用的通配符如下：

| 通配符      | 含义                                 | 实例                                                         |
| :---------- | :----------------------------------- | :----------------------------------------------------------- |
| *           | 匹配 0 或多个字符                    | `a*b`，a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如 aabcb, axyzb, a012b, ab |
| ?           | 匹配任意单个字符                     | `a?b`，a与b之间有且只有一个字符, 可以是任意字符, 如 aab, abb, acb, a0b |
| [list]      | 匹配 list 中的任意单个字符           | `a[xyz]b`，a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如 axb, ayb, azb。 |
| [!list]     | 匹配除 list 中的任意单一字符         | `a[!0-9]b`，a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如 axb, aab, a-b。 |
| [c1-c2]     | 匹配 c1-c2 中的任意单一字符          | `a[0-9]b`，匹配0与9之间其中一个字符，如 a0b, a1b... a9b      |
| {s1,s2,...} | 匹配 s1 或 s2 (或更多)中的一个字符串 | `a{abc,xyz,123}b`，a与b之间只能是abc或xyz或123这三个字符串之一 |



### 转义字符

有的时候，我们匹配的内容里面会存在 `*`，`?`，`[`等通配符中的符号。为了表示他们原来的意思，我们需要使用转义字符 `\`，如 `a\[ac\]c` 表示匹配 `a[a]c` 或 `a[c]c`。`\` 本身用 `\\` 表示。



### 分清楚通配符表达式和正则表达式

通配符看起来和正则表达式很像，但他们并不是同一种东西。**正则表达式中的那些量词的匹配规则和这里提到的几个通配符的匹配规则并不相同。**如正则表达式中 `*` 表示重复前一个字符任意次，`ab*` 表示的是那些 `a` 后面跟 0 个或多个 `b` 的字符串， 而通配符表达式中 `*` 表示 0 或多个任意字符， `ab*` 表示的是那些 `ab` 后面跟任意个字符的字符串。

而且**正则表达式一般是部分匹配的**，用来匹配内容中的一部分，如用正则表达式 `a` 去匹配 `bac` 这段字符串时，匹配是成功的，匹配到的内容是 `a`。但是**通配符表达式的话是全部匹配的**，表达式要匹配整个字符串才算匹配成功，如用通配符表达式 `a` 取匹配 `bac` 这段字符串时，匹配是失败的。

在 Shell 命令中，通常**用通配符表达式来匹配文件名**，而**用正则表达式来匹配一段文本内容**。以 `grep` 命令为例，`grep` 命令可以在指定的文件中，挑选出和表达式匹配的那些行，其中指定文件是用的通配符表达式，而文本内容的匹配用的是正则表达式。

今天使用 `grep` 时，就因为没分清楚他们，忙活了半天。情况是这样的，我想看一个 jar 包里是不是有 pom 相关的文件，所以就输入了下面命令

```
jar tf maven-model-builder-3.5.3.jar | grep 'pom*'  # 这里是正则表达式，匹配有po、pom、pom+子串的字符串
```

结果输入了一堆文件，而且很多文件都没有 pom 这串字符串的。输出内容是这样的：

```
...
org/apache/maven/model/composition/
org/apache/maven/model/interpolation/
org/apache/maven/model/superpom/
org/apache/maven/model/composition/DependencyManagementImporter.class
...
```

这就是因为我把通配符表达式和正则表达式搞混了，后来知道原因后，用下面的命令才得到想要的内容。

```
jar tf maven-model-builder-3.5.3.jar | grep 'pom.*'
```

使用 Shell 命令时，要分清楚哪里用的是通配符表达式，哪里用的是正则表达式。



链接：https://www.jianshu.com/p/25f3d0cd5fdc







### 其他

文本命令行界面（command line interface，CLI）